/*-
 * #%L
 * org.matonto.web
 * $Id:$
 * $HeadURL:$
 * %%
 * Copyright (C) 2016 iNovex Information Systems, Inc.
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * #L%
 */
(function() {
    'use strict';

    angular
        /**
         * @ngdoc overview
         * @name catalogManager
         *
         * @description
         * The `catalogManager` module only provides the `catalogManagerService` service which
         * provides access to the MatOnto catalog REST endpoints and utility functions for the
         * results of those endpoints
         */
        .module('catalogManager', [])
        /**
         * @ngdoc service
         * @name catalogManager.service:catalogManagerService
         * @requires $http
         * @requires $q
         * @requires prefixes.service:prefixes
         * @requires ontologyManager.service:ontologyManagerService
         *
         * @description
         * `catalogManagerService` is a service that provides access to the MatOnto catalog REST
         * endpoints and utility functions for the record, distribution, version, and branch objects
         * that are returned.
         */
        .service('catalogManagerService', catalogManagerService);

        catalogManagerService.$inject = ['$window', '$http', '$q', 'prefixes', 'utilService'];

        function catalogManagerService($window, $http, $q, prefixes, utilService) {
            var self = this,
                util = utilService,
                prefix = '/matontorest/catalogs';

            /**
             * @ngdoc property
             * @name sortOptions
             * @propertyOf catalogManager.service:catalogManagerService
             * @type {Object[]}
             *
             * @description
             * `sortOptions` contains a list of objects representing all sort options for both Catalogs.
             * Each object's structure is as follows:
             * ```
             * {
             *     field: 'http://purl.org/dc/terms/title',
             *     ascending: true,
             *     label: 'Title (asc)'
             * }
             * ```
             * This list is populated by the `initialize` method.
             */
            self.sortOptions = [];
            /**
             * @ngdoc property
             * @name recordTypes
             * @propertyOf catalogManager.service:catalogManagerService
             * @type {string[]}
             *
             * @description
             * `recordTypes` contains a list of IRI strings of all types of records contained in both Catalogs.
             * This list is populated by the `initialize` method.
             */
            self.recordTypes = [];
            /**
             * @ngdoc property
             * @name localCatalog
             * @propertyOf catalogManager.service:catalogManagerService
             * @type {Object}
             *
             * @description
             * `localCatalog` contains the JSON-LD object for the local Catalog in MatOnto. It is populated by
             * the `initialize` method.
             */
            self.localCatalog = undefined;
            /**
             * @ngdoc property
             * @name distributedCatalog
             * @propertyOf catalogManager.service:catalogManagerService
             * @type {Object}
             *
             * @description
             * `distributedCatalog` contains the JSON-LD object for the distributed Catalog in MatOnto. It is
             * populated by the `initialize` method.
             */
            self.distributedCatalog = undefined;

            /**
             * @ngdoc method
             * @name initialize
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Initializes the `sortOptions`, `recordTypes`, `localCatalog`, and `distributedCatalog` of the
             * catalogManagerService using the `getSortOptions` and `getRecordTypes` methods along with the
             * GET /matontorest/catalogs endpoint. If the local or distributed Catalog cannot be found, rejects
             * with an error message.
             *
             * @returns {Promise} A promise that resolves if initialization was successful or is rejected
             * with an error message
             */
            self.initialize = function() {
                return $q.all([self.getRecordTypes(), self.getSortOptions(), $http.get(prefix)])
                    .then(responses => {
                        self.localCatalog = _.find(responses[2].data, {[prefixes.dcterms + 'title']: [{'@value': 'MatOnto Catalog (Local)'}]});
                        self.distributedCatalog = _.find(responses[2].data, {[prefixes.dcterms + 'title']: [{'@value': 'MatOnto Catalog (Distributed)'}]});
                        if (!self.localCatalog) {
                            return $q.reject('Could not find local catalog');
                        }
                        if (!self.distributedCatalog) {
                            return $q.reject('Could not find distributed catalog');
                        }
                        self.recordTypes = responses[0];
                        _.forEach(responses[1], option => {
                            var label = util.getBeautifulIRI(option);
                            if (!_.includes(self.sortOptions, {field: option})) {
                                self.sortOptions.push({
                                    field: option,
                                    asc: true,
                                    label: label + ' (asc)'
                                }, {
                                    field: option,
                                    asc: false,
                                    label: label + ' (desc)'
                                });
                            }
                        });
                    }, error => $q.reject('Error in catalogManager initialization'));
            }

            /**
             * @ngdoc method
             * @name getRecordTypes
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/record-types endpoint and returns the
             * array of record type IRIs.
             *
             * @returns {Promise} A promise that resolves to an array of the IRIs for all
             * record types in the catalog
             */
            self.getRecordTypes = function() {
                return $http.get(prefix + '/record-types')
                    .then(response => $q.resolve(response.data));
            }

            /**
             * @ngdoc method
             * @name getSortOptions
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/sort-options endpoint and returns the
             * array of record property IRIs.
             *
             * @return {Promise} A promise that resolves to an array of the IRIs for all
             * supported record properties to sort by
             */
            self.getSortOptions = function() {
                return $http.get(prefix + '/sort-options')
                    .then(response => $q.resolve(response.data));
            }

            /**
             * @ngdoc method
             * @name getResultsPage
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls whichever endpoint is in the passed URL and returns the paginated response for that
             * endpoint.
             *
             * @param  {string} url A URL for a paginated call. Typically, this URL will be one of the URLs
             * in the "link" header of a paginated response.
             *
             * @returns {Promise} A promise that either resolves with a paginated response or is rejected
             * with a error message
             */
            self.getResultsPage = function(url) {
                var deferred = $q.defer();
                $http.get(url)
                    .then(deferred.resolve, error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name getRecords
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/{catalogId}/records endpoint and returns the paginated
             * response for the query using the passed page index, limit, sort option from the `sortOptions`
             * array, and Record type filter IRI from the `recordTypes` array. The data of the response will
             * be the array of Records, the "x-total-count" headers will contain the total number of Records
             * matching the query, and the "link" header will contain the URLs for the next and previous page
             * if present.
             *
             * @param {string} catalogId The id of the Catalog to retrieve Records from
             * @param {Object} paginatedConfig A configuration object for paginated requests
             * @param {number} paginatedConfig.pageIndex The index of the page of results to retrieve
             * @param {number} paginatedConfig.limit The number of results per page
             * @param {Object} paginatedConfig.sortOption A sort option object from the `sortOptions` array
             * @param {string} paginatedConfig.recordType A record type IRI string from the `recordTypes` array
             * @param {string} paginatedConfig.searchText The text to search for within the list of Records
             * @returns {Promise} A promise that either resolves with the paginated response or is rejected
             * with a error message
             */
            self.getRecords = function(catalogId, paginatedConfig) {
                var deferred = $q.defer(),
                    config = {
                        params: util.paginatedConfigToParams(paginatedConfig)
                    };
                setDefaultSort(config.params);
                if (_.get(paginatedConfig, 'searchText')) {
                    config.params.searchText = paginatedConfig.searchText;
                }
                if (_.get(paginatedConfig, 'recordType')) {
                    config.params.type = paginatedConfig.recordType;
                }
                $http.get(prefix + '/' + encodeURIComponent(catalogId) + '/records', config)
                    .then(deferred.resolve, error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name getRecord
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/{catalogId}/records/{recordId} endpoint with the passed
             * Catalog and Record ids and returns the matching Record object if it exists.
             *
             * @param {string} recordId The id of the Record to retrieve
             * @param {string} catalogId The id of the Catalog with the specified Record
             * @return {Promise} A promise that resolves to the Record if it exists or is rejected with
             * an error message
             */
            self.getRecord = function(recordId, catalogId) {
                var deferred = $q.defer();
                $http.get(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId))
                    .then(response => deferred.resolve(response.data), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name createRecord
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the POST /matontorest/catalogs/{catalogId}/records endpoint with the passed Catalog id and
             * metadata and creates a new Record for the identified Catalog. Returns a Promise with the IRI of the
             * new Record if successful or rejects with an error message.
             *
             * @param {string} catalogId The id of the Catalog to create the Record in
             * @param {Object} recordConfig A configuration object containing metadata for the new Record
             * @param {string} recordConfig.type A record type IRI string from the `recordTypes` array
             * @param {string} recordConfig.title The required title of the new Record
             * @param {string} recordConfig.identifier The optional identifier string for the new Record
             * @param {string} recordConfig.description The optional description of the new Record
             * @param {string[]} recordConfig.keywords The optional keywords to associate with the new Record.
             * @return {Promise} A promise that resolves to the IRI of the new Record or is rejected with an error
             * message
             */
            self.createRecord = function(catalogId, recordConfig) {
                var deferred = $q.defer(),
                    fd = new FormData(),
                    config = {
                        transformRequest: _.identity,
                        headers: {
                            'Content-Type': undefined
                        }
                    };
                fd.append('type', recordConfig.recordType);
                fd.append('title', recordConfig.title);
                if (_.has(recordConfig, 'description')) {
                    fd.append('description', recordConfig.description);
                }
                if (_.get(recordConfig, 'keywords', []).length > 0) {
                    fd.append('keywords', _.join(recordConfig.keywords, ','));
                }
                $http.post(prefix + '/' + encodeURIComponent(catalogId) + '/records', fd, config)
                    .then(response => deferred.resolve(response.data), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name updateRecord
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the PUT /matontorest/catalogs/{catalogId}/records/{recordId} endpoint with the passed Catalog and
             * Record ids and updates the identified Record with the passed Record JSON-LD object.
             *
             * @param {string} recordId The id of the Record to update
             * @param {string} catalogId The id of the Catalog with the specified Record
             * @param {Object} newRecord The JSON-LD object of the new Record
             * @return {Promise} A promise that resolves if the update was successful or rejects with an error message
             */
            self.updateRecord = function(recordId, catalogId, newRecord) {
                var deferred = $q.defer();
                $http.put(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId), angular.toJson(newRecord))
                    .then(response => deferred.resolve(recordId), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name deleteRecord
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the DELETE /matontorest/catalogs/{catalogId}/records/{recordId} endpoint with the passed Catalog
             * and Record ids and removes the identified Record and all associated entities from MatOnto.
             *
             * @param {string} recordId The id of the Record to delete
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @return {Promise} A promise that resolves if the deletion was successful or rejects with an error message
             */
            self.deleteRecord = function(recordId, catalogId) {
                var deferred = $q.defer();
                $http.delete(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId))
                    .then(response => deferred.resolve(), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name getRecordDistributions
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/{catalogId}/records/{recordId}/distributions endpoint and
             * returns the paginated response using the passed page index, limit, and sort option from the
             * `sortOption` array. The data of the response will be the array of Distributions, the
             * "x-total-count" headers will contain the total number of Distributions matching the query, and
             * the "link" header will contain the URLs for the next and previous page if present.
             *
             * @param {string} recordId The id of the Record to retrieve the Distributions of
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @param {Object} paginatedConfig A configuration object for paginated requests
             * @param {number} paginatedConfig.pageIndex The index of the page of results to retrieve
             * @param {number} paginatedConfig.limit The number of results per page
             * @param {Object} paginatedConfig.sortOption A sort option object from the `sortOptions` array
             * @return {Promise} A promise that resolves to the paginated response or is rejected
             * with a error message
             */
            self.getRecordDistributions = function(recordId, catalogId, paginatedConfig) {
                var deferred = $q.defer(),
                    config = {
                        params: util.paginatedConfigToParams(paginatedConfig)
                    };
                setDefaultSort(config.params);
                $http.get(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId) + '/distributions', config)
                    .then(deferred.resolve, error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name getRecordDistribution
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/{catalogId}/records/{recordId}/distributions/{distributionId}
             * endpoint and returns the matching Distribution JSON-LD object.
             *
             * @param {string} distributionId The id of the Distribution to retrieve
             * @param {string} recordId The id of the Record with the specified Distribution
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @return {Promise} A promise that resolves to the Distribution if it is found or is rejected
             * with an error message
             */
            self.getRecordDistribution = function(distributionId, recordId, catalogId) {
                var deferred = $q.defer();
                $http.get(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId) + '/distributions/' + encodeURIComponent(distributionId))
                    .then(response => deferred.resolve(response.data), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name createRecordDistribution
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the POST /matontorest/catalogs/{catalogId}/records/{recordId}/distributions endpoint with the passed
             * Catalog and Record id and metadata and creates a new Distribution for the identified Record. Returns a
             * Promise with the IRI of the new Distribution if successful or rejects with an error message.
             *
             * @param {string} recordId The id of the Record to create the Distribution for
             * @param {string} catalogId The id of the Catalog the Record should be a part of
             * @param {Object} distributionConfig A configuration object containing metadata for the new Distribution
             * @param {string} distributionConfig.title The required title of the new Distribution
             * @param {string} distributionConfig.description The optional description of the new Distribution
             * @param {string} distributionConfig.format The optional format of the new Distribution (should be a MIME type)
             * @param {string} distributionConfig.accessURL The optional access URL of the new Distribution
             * @param {string} distributionConfig.downloadURL The optional download URL of the new Distribution
             * @return {Promise} A promise the resolves to the IRI of the new Distribution or is rejected with an error
             * message
             */
            self.createRecordDistribution = function(recordId, catalogId, distributionConfig) {
                var deferred = $q.defer(),
                    fd = new FormData(),
                    config = {
                        transformRequest: _.identity,
                        headers: {
                            'Content-Type': undefined
                        }
                    };
                fd.append('title', distributionConfig.title);
                if (_.has(distributionConfig, 'description')) {
                    fd.append('description', distributionConfig.description);
                }
                if (_.has(distributionConfig, 'format')) {
                    fd.append('format', distributionConfig.format);
                }
                if (_.has(distributionConfig, 'accessURL')) {
                    fd.append('accessURL', distributionConfig.accessURL);
                }
                if (_.has(distributionConfig, 'downloadURL')) {
                    fd.append('downloadURL', distributionConfig.downloadURL);
                }
                $http.post(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId) + '/distributions', fd, config)
                    .then(response => deferred.resolve(response.data), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name updateRecordDistribution
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the PUT /matontorest/catalogs/{catalogId}/records/{recordId}/distributions/{distributionId} endpoint with
             * the passed Catalog, Record, and Distribution ids and updates the identified Distribution with the passed
             * Distribution JSON-LD object.
             *
             * @param {string} distributionId The id of the Distribution to update
             * @param {string} recordId The id of the Record with the specified Distribution
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @param {Object} newDistribution The JSON-LD object of the new Distribution
             * @return {Promise} A promise that resolves if the update was successful or rejects with an error message
             */
            self.updateRecordDistribution = function(distributionId, recordId, catalogId, newDistribution) {
                var deferred = $q.defer();
                $http.put(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId) + '/distributions/' + encodeURIComponent(distributionId), angular.toJson(newDistribution))
                    .then(response => deferred.resolve(distributionId), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name deleteRecordDistribution
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the DELETE /matontorest/catalogs/{catalogId}/records/{recordId}/distributions/{distributionId} endpoint
             * with the passed Catalog, Record, and Distribution ids and removes the identified Distribution and all associated
             * entities from MatOnto.
             *
             * @param {string} distributionId The id of the Distribution to delete
             * @param {string} recordId The id of the Record with the specified Distribution
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @return {Promise} A promise that resolves if the deletion was successful or rejects with an error message
             */
            self.deleteRecordDistribution = function(distributionId, recordId, catalogId) {
                var deferred = $q.defer();
                $http.delete(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId) + '/distributions/' + encodeURIComponent(distributionId))
                    .then(response => deferred.resolve(), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name getRecordVersions
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/{catalogId}/records/{recordId}/versions endpoint and
             * returns the paginated response using the passed page index, limit, and sort option from the
             * `sortOption` array. The data of the response will be the array of Versions, the
             * "x-total-count" headers will contain the total number of Versions matching the query, and
             * the "link" header will contain the URLs for the next and previous page if present.
             *
             * @param {string} recordId The id of the Record to retrieve the Versions of
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @param {Object} paginatedConfig A configuration object for paginated requests
             * @param {number} paginatedConfig.pageIndex The index of the page of results to retrieve
             * @param {number} paginatedConfig.limit The number of results per page
             * @param {Object} paginatedConfig.sortOption A sort option object from the `sortOptions` array
             * @return {Promise} A promise that resolves to the paginated response or is rejected
             * with a error message
             */
            self.getRecordVersions = function(recordId, catalogId, paginatedConfig) {
                var deferred = $q.defer(),
                    config = {
                        params: util.paginatedConfigToParams(paginatedConfig)
                    };
                setDefaultSort(config.params);
                $http.get(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId) + '/versions', config)
                    .then(deferred.resolve, error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name getRecordLatestVersion
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/{catalogId}/records/{recordId}/versions/latest
             * endpoint and returns the matching Version JSON-LD object for the Record's latest Version.
             *
             * @param {string} recordId The id of the Record to retrieve the latest Version of
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @return {Promise} A promise that resolves to the Version if it is found or is rejected
             * with an error message
             */
            self.getRecordLatestVersion = function(recordId, catalogId) {
                return getRecordVersion('latest', recordId, catalogId);
            }

            /**
             * @ngdoc method
             * @name getRecordVersion
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/{catalogId}/records/{recordId}/versions/{versionId}
             * endpoint and returns the matching Version JSON-LD object.
             *
             * @param {string} versionId The id of the Version to retrieve
             * @param {string} recordId The id of the Record with the specified Version
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @return {Promise} A promise that resolves to the Version if it is found or is rejected
             * with an error message
             */
            self.getRecordVersion = function(versionId, recordId, catalogId) {
                return getRecordVersion(encodeURIComponent(versionId), recordId, catalogId);
            }


            /**
             * @ngdoc method
             * @name createRecordVersion
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the POST /matontorest/catalogs/{catalogId}/records/{recordId}/versions endpoint with the passed
             * Catalog and Record ids and metadata and creates a new Version for the identified Record. Returns a
             * Promise with the IRI of the new Version if successful or rejects with an error message.
             *
             * @param {string} recordId The id of the Record to create the Version for
             * @param {string} catalogId The id of the Catalog the Record should be a part of
             * @param {Object} versionConfig A configuration object containing metadata for the new Version
             * @param {string} versionConfig.title The required title of the new Version
             * @param {string} versionConfig.description The optional description of the new Version
             * @return {Promise} A promise the resolves to the IRI of the new Version or is rejected with an error
             * message
             */
            self.createRecordVersion = function(recordId, catalogId, versionConfig) {
                versionConfig.type = prefixes.catalog + 'Version';
                return createVersion(recordId, catalogId, versionConfig);
            }

            /**
             * @ngdoc method
             * @name createRecordTag
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the POST /matontorest/catalogs/{catalogId}/records/{recordId}/versions endpoint with the passed
             * Catalog and Record ids, metadata, and associated Commit id and creates a new Tag for the identified
             * Record. Returns a Promise with the IRI of the new Tag if successful or rejects with an error message.
             *
             * @param {string} recordId The id of the Record to create the Tag for
             * @param {string} catalogId The id of the Catalog the Record should be a part of
             * @param {Object} versionConfig A configuration object containing metadata for the new Version
             * @param {string} versionConfig.title The required title of the new Version
             * @param {string} versionConfig.description The optional description of the new Version
             * @param {string} commitId The id of the Commit to associate with the new Tag
             * @return {Promise} A promise the resolves to the IRI of the new Tag or is rejected with an error
             * message
             */
            self.createRecordTag = function(recordId, catalogId, versionConfig, commitId) {
                versionConfig.type = prefixes.catalog + 'Tag';
                return createVersion(recordId, catalogId, versionConfig)
                    .then(iri => self.getRecordVersion(iri, recordId, catalogId), error => $q.reject(error))
                    .then(version => {
                        version[prefixes.catalog + 'commit'] = [{'@id': commitId}];
                        return self.updateRecordVersion(version['@id'], recordId, catalogId, version);
                    }, error => $q.reject(error))
            }

            /**
             * @ngdoc method
             * @name updateRecordVersion
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the PUT /matontorest/catalogs/{catalogId}/records/{recordId}/versions/{versionId} endpoint with
             * the passed Catalog, Record, and Version ids and updates the identified Version with the passed
             * Version JSON-LD object.
             *
             * @param {string} versionId The id of the Version to update
             * @param {string} recordId The id of the Record with the specified Version
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @param {Object} newVersion The JSON-LD object of the new Version
             * @return {Promise} A promise that resolves if the update was successful or rejects with an error message
             */
            self.updateRecordVersion = function(versionId, recordId, catalogId, newVersion) {
                var deferred = $q.defer();
                $http.put(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId) + '/versions/' + encodeURIComponent(versionId), angular.toJson(newVersion))
                    .then(response => deferred.resolve(response.data), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name deleteRecordVersion
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the DELETE /matontorest/catalogs/{catalogId}/records/{recordId}/versions/{versionId} endpoint
             * with the passed Catalog, Record, and Version ids and removes the identified Version and all associated
             * entities from MatOnto.
             *
             * @param {string} versionId The id of the Version to delete
             * @param {string} recordId The id of the Record with the specified Version
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @return {Promise} A promise that resolves if the deletion was successful or rejects with an error message
             */
            self.deleteRecordVersion = function(versionId, recordId, catalogId) {
                var deferred = $q.defer();
                $http.delete(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId) + '/versions/' + encodeURIComponent(versionId))
                    .then(response => deferred.resolve(), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name getVersionCommit
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/{catalogId}/records/{recordId}/versions/{versionId}/commit endpoint
             * with the passed Catalog, Record, and Version ids and retrieves the associated Commit for the identified
             * Version in the passed RDF format.
             *
             * @param {string} versionId The id of the Version to retrieve the Commit of
             * @param {string} recordId The id of the Record with the specified Version
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @param {string='jsonld'} format The RDF format to return the Commit additions and deletions in
             * @return {Promise} A promise that resolves to the Version's Commit if found or rejects with an error message
             */
            self.getVersionCommit = function(versionId, recordId, catalogId, format = 'jsonld') {
                var deferred = $q.defer(),
                    config = {
                        params: {format}
                    };
                $http.get(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId) + '/versions/' + encodeURIComponent(versionId) + '/commit', config)
                    .then(response => deferred.resolve(response.data), error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name getVersionDistributions
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/{catalogId}/records/{recordId}/versions/{versionId}/distributions
             * endpoint and returns the paginated response using the passed page index, limit, and sort option from the
             * `sortOption` array. The data of the response will be the array of Distributions, the
             * "x-total-count" headers will contain the total number of Distributions matching the query, and
             * the "link" header will contain the URLs for the next and previous page if present.
             *
             * @param {string} versionId The id of the Version to retrieve the Distributions of
             * @param {string} recordId The id of the Record to the Version should be part of
             * @param {string} catalogId The id of the Catalog the Record should be part of
             * @param {Object} paginatedConfig A configuration object for paginated requests
             * @param {number} paginatedConfig.pageIndex The index of the page of results to retrieve
             * @param {number} paginatedConfig.limit The number of results per page
             * @param {Object} paginatedConfig.sortOption A sort option object from the `sortOptions` array
             * @return {Promise} A promise that resolves to the paginated response or is rejected
             * with a error message
             */
            self.getVersionDistributions = function(versionId, recordId, catalogId, paginatedConfig) {
                var deferred = $q.defer(),
                    config = {
                        params: util.paginatedConfigToParams(paginatedConfig)
                    };
                setDefaultSort(config.params);
                $http.get(prefix + '/' + encodeURIComponent(catalogId) + '/records/' + encodeURIComponent(recordId) + '/versions/' + encodeURIComponent(versionId) + '/distributions', config)
                    .then(deferred.resolve, error => util.onError(error, deferred));
                return deferred.promise;
            }

            /**
             * @ngdoc method
             * @name getRecordDistribution
             * @methodOf catalogManager.service:catalogManagerService
             *
             * @description
             * Calls the GET /matontorest/catalogs/{catalogId}/records/{recordId}/versions/{versionId}/distributions/{distributionId}
             * endpoint and returns the matching Distribution JSON-LD object.
             *
             * @param {string} distributionId The id of the Distribution to retrieve
             * @param {string} recordId The id of the Version with 